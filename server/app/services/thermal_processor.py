# server/app/services/thermal_processor.py
import os
import csv
import json
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, Optional, Any
from datetime import datetime
import numpy as np
from PIL import Image

from app.core.config import settings


class ThermalProcessor:
    """
    Handles processing of thermal BMT files.
    Extracts thermal data, real images, and generates CSV files.
    """

    def __init__(self):
        self.temp_dir = Path(tempfile.gettempdir()) / "thermal_analyzer"
        self.temp_dir.mkdir(exist_ok=True)
        
        # Path to C# extraction tool (configurable via environment)
        self.extractor_path = os.getenv(
            "BMT_EXTRACTOR_PATH",
            r"BmtExtract\BmtExtract\bin\Debug\net8.0\BmtExtract.exe"
        )

    async def process_bmt_file(self, file_path: str) -> Dict[str, Any]:
        """
        Process BMT file and extract thermal data, real image, and metadata.
        
        Returns:
        {
            "success": bool,
            "message": str,
            "thermal_image_path": str,
            "real_image_path": str,
            "csv_url": str,
            "metadata": dict,
            "thermal_data": dict
        }
        """
        try:
            # Create output directory
            output_dir = self.temp_dir / f"bmt_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            output_dir.mkdir(exist_ok=True, parents=True)

            # Check if C# extractor exists
            if os.path.exists(self.extractor_path):
                # Use C# extractor
                result = await self._process_with_csharp(file_path, str(output_dir))
            else:
                # Fallback to Python-based extraction
                result = await self._process_with_python(file_path, str(output_dir))

            return result

        except Exception as e:
            return {
                "success": False,
                "message": f"Error processing BMT file: {str(e)}"
            }

    async def _process_with_csharp(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
        """Process using C# BmtExtract tool"""
        try:
            # Convert to absolute paths
            abs_bmt_path = os.path.abspath(bmt_path)
            abs_output_dir = os.path.abspath(output_dir)
            
            # Create output directory
            os.makedirs(abs_output_dir, exist_ok=True, parents=True)
            
            print(f"DEBUG: BMT file: {abs_bmt_path}")
            print(f"DEBUG: Output dir: {abs_output_dir}")
            print(f"DEBUG: Extractor: {self.extractor_path}")
            
            # Check if paths exist/are valid
            if not os.path.exists(abs_bmt_path):
                raise FileNotFoundError(f"BMT file not found: {abs_bmt_path}")
            
            if not os.path.isdir(abs_output_dir):
                raise NotADirectoryError(f"Output directory is invalid: {abs_output_dir}")
            
            # Run C# extractor with absolute paths
            # C# will output all files directly to this folder
            process = subprocess.run(
                [self.extractor_path, abs_bmt_path, abs_output_dir],
                capture_output=True,
                text=True,
                timeout=30,
                cwd=os.path.dirname(self.extractor_path)  # Set working directory to extractor location
            )
            
            print(f"DEBUG: C# Return code: {process.returncode}")
            print(f"DEBUG: C# Stdout:\n{process.stdout}")
            print(f"DEBUG: C# Stderr:\n{process.stderr}")

            if process.returncode != 0:
                raise RuntimeError(f"C# extractor failed: {process.stderr}")

            # Read extracted data.json from output_dir
            json_path = os.path.join(output_dir, "data.json")
            if not os.path.exists(json_path):
                raise FileNotFoundError("data.json not generated by extractor")

            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)

            # Process files that are already in output_dir
            result = await self._process_extracted_files(output_dir, data)
            
            return result

        except subprocess.TimeoutExpired:
            raise RuntimeError("C# extractor timeout")
        except Exception as e:
            raise RuntimeError(f"C# extraction failed: {str(e)}")

    async def _process_extracted_files(self, output_dir: str, data: Dict) -> Dict[str, Any]:
        """Process all files that C# extractor created in output_dir"""
        try:
            thermal_images = {}
            real_image_path = None
            csv_path = None
            
            # خواندن فایل‌های تولید شده توسط C#
            for item in os.listdir(output_dir):
                file_path = os.path.join(output_dir, item)
                
                if os.path.isfile(file_path):
                    # Track different file types
                    if item.endswith('.png'):
                        if 'visual' in item:
                            real_image_path = file_path
                        elif 'thermal' in item:
                            # Extract palette name from filename
                            # e.g., "example12_thermal_iron.png" -> "iron"
                            palette_name = item.split('_thermal_')[-1].replace('.png', '')
                            thermal_images[palette_name] = file_path
                    
                    elif item.endswith('.csv'):
                        csv_path = file_path
                    
                    elif item == 'data.json':
                        # data.json is already in output_dir
                        continue

            # Extract metadata from C# output
            metadata = {
                "device": data.get("DeviceInfo", {}).get("DeviceName", "Unknown"),
                "serial_number": data.get("DeviceInfo", {}).get("SerialNumber", ""),
                "emissivity": data.get("MeasurementInfo", {}).get("Emissivity", 0.95),
                "reflected_temp": data.get("MeasurementInfo", {}).get("ReflectedTemperature", 20.0),
                "humidity": data.get("MeasurementInfo", {}).get("Humidity", 0),
                "temperature_unit": data.get("MeasurementInfo", {}).get("TemperatureUnit", "°C"),
                "captured_at": data.get("ImageInfo", {}).get("CreationDateTime", datetime.utcnow().isoformat()),
                "fov": data.get("DeviceInfo", {}).get("FieldOfView", ""),
            }

            thermal_data = {
                "width": data.get("ImageInfo", {}).get("Width", 0),
                "height": data.get("ImageInfo", {}).get("Height", 0),
                "min_temp": data.get("TemperatureStats", {}).get("Min", 0),
                "max_temp": data.get("TemperatureStats", {}).get("Max", 100),
                "avg_temp": data.get("TemperatureStats", {}).get("Average", 0),
                "analysis_mode": data.get("TemperatureStats", {}).get("AnalysisMode", "full"),
            }

            # Save final output JSON with all information
            final_json_path = os.path.join(output_dir, "metadata.json")
            final_data = {
                "success": True,
                "message": "BMT processed successfully",
                "thermal_images": thermal_images,
                "real_image_path": real_image_path,
                "csv_path": csv_path,
                "metadata": metadata,
                "thermal_data": thermal_data,
                "file_info": data.get("FileInfo", {})
            }
            
            with open(final_json_path, 'w', encoding='utf-8') as f:
                json.dump(final_data, f, indent=2, ensure_ascii=False)

            return final_data

        except Exception as e:
            raise RuntimeError(f"Failed to copy C# output: {str(e)}")

    async def _process_with_python(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
        """Fallback Python-based extraction (basic implementation)"""
        try:
            with open(bmt_path, 'rb') as f:
                content = f.read()

            # Try to extract embedded JPEG (real image)
            real_image_path = None
            jpeg_start = content.find(b'\xFF\xD8\xFF')
            if jpeg_start != -1:
                jpeg_end = content.find(b'\xFF\xD9', jpeg_start)
                if jpeg_end != -1:
                    jpeg_data = content[jpeg_start:jpeg_end + 2]
                    real_image_path = os.path.join(output_dir, "real_image.jpg")
                    with open(real_image_path, 'wb') as img_file:
                        img_file.write(jpeg_data)

            # Generate dummy thermal data for testing
            width, height = 320, 240
            temperature_matrix = np.random.uniform(15, 35, (height, width)).tolist()
            
            # Save as CSV
            csv_path = os.path.join(output_dir, "thermal_data.csv")
            with open(csv_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['Y', 'X', 'Temperature'])
                for y, row in enumerate(temperature_matrix):
                    for x, temp in enumerate(row):
                        writer.writerow([y, x, f"{temp:.2f}"])

            # Generate thermal image visualization
            thermal_image_path = self._generate_thermal_visualization(
                temperature_matrix,
                os.path.join(output_dir, "thermal_image_iron.png")
            )

            metadata = {
                "emissivity": 0.95,
                "reflected_temp": 20.0,
                "humidity": 50.0,
                "device": "Unknown Camera",
                "captured_at": datetime.utcnow().isoformat()
            }

            thermal_data = {
                "width": width,
                "height": height,
                "min_temp": float(np.min(temperature_matrix)),
                "max_temp": float(np.max(temperature_matrix)),
                "avg_temp": float(np.mean(temperature_matrix))
            }

            return {
                "success": True,
                "message": "BMT processed with Python fallback",
                "thermal_images": {"iron": thermal_image_path},
                "real_image_path": real_image_path,
                "csv_path": csv_path,
                "metadata": metadata,
                "thermal_data": thermal_data
            }

        except Exception as e:
            raise RuntimeError(f"Python extraction failed: {str(e)}")

    def _generate_thermal_visualization(
        self, 
        temperature_matrix: list, 
        output_path: str
    ) -> str:
        """Generate thermal image visualization from temperature matrix"""
        try:
            import matplotlib
            matplotlib.use('Agg')
            import matplotlib.pyplot as plt
            from matplotlib.colors import LinearSegmentedColormap

            # Create iron colormap (similar to FLIR)
            colors = ['#000033', '#0000aa', '#0088ff', '#00ddff', 
                     '#88ff55', '#ffaa00', '#ff0000', '#aa0000']
            n_bins = 256
            cmap = LinearSegmentedColormap.from_list('iron', colors, N=n_bins)

            # Create figure
            fig, ax = plt.subplots(figsize=(8, 6))
            im = ax.imshow(temperature_matrix, cmap=cmap, aspect='auto')
            plt.colorbar(im, ax=ax, label='Temperature (°C)')
            ax.axis('off')
            
            plt.tight_layout()
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close(fig)

            return output_path

        except Exception as e:
            print(f"Error generating thermal visualization: {e}")
            # Create simple grayscale fallback
            arr = np.array(temperature_matrix, dtype=np.float32)
            normalized = ((arr - arr.min()) / (arr.max() - arr.min()) * 255).astype(np.uint8)
            img = Image.fromarray(normalized, mode='L')
            img.save(output_path)
            return output_path

    def cleanup_temp_files(self, max_age_hours: int = 24):
        """Clean up old temporary files"""
        try:
            current_time = datetime.now()
            for item in self.temp_dir.iterdir():
                if item.is_dir():
                    creation_time = datetime.fromtimestamp(item.stat().st_ctime)
                    age_hours = (current_time - creation_time).total_seconds() / 3600
                    
                    if age_hours > max_age_hours:
                        shutil.rmtree(item)
        except Exception as e:
            print(f"Error cleaning temp files: {e}")
# # server/app/services/thermal_processor.py
# import os
# import csv
# import json
# import subprocess
# import tempfile
# import shutil
# from pathlib import Path
# from typing import Dict, Optional, Any
# from datetime import datetime
# import numpy as np
# from PIL import Image

# from app.core.config import settings


# class ThermalProcessor:
#     """
#     Handles processing of thermal BMT files.
#     Extracts thermal data, real images, and generates CSV files.
#     """

#     def __init__(self):
#         self.temp_dir = Path(tempfile.gettempdir()) / "thermal_analyzer"
#         self.temp_dir.mkdir(exist_ok=True)
        
#         # Path to C# extraction tool (configurable via environment)
#         self.extractor_path = os.getenv(
#             "BMT_EXTRACTOR_PATH",
#             r"BmtExtract\BmtExtract\bin\Debug\net8.0\BmtExtract.exe"
#         )

#     async def process_bmt_file(self, file_path: str) -> Dict[str, Any]:
#         """
#         Process BMT file and extract thermal data, real image, and metadata.
        
#         Returns:
#         {
#             "success": bool,
#             "message": str,
#             "thermal_image_path": str,
#             "real_image_path": str,
#             "csv_url": str,  # URL to CSV temperature data
#             "metadata": dict,
#             "thermal_data": dict
#         }
#         """
#         try:
#             # Create output directory
#             output_dir = self.temp_dir / f"bmt_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
#             output_dir.mkdir(exist_ok=True)

#             # Check if C# extractor exists
#             if os.path.exists(self.extractor_path):
#                 # Use C# extractor
#                 result = await self._process_with_csharp(file_path, str(output_dir))
#             else:
#                 # Fallback to Python-based extraction
#                 result = await self._process_with_python(file_path, str(output_dir))

#             return result

#         except Exception as e:
#             return {
#                 "success": False,
#                 "message": f"Error processing BMT file: {str(e)}"
#             }

#     async def _process_with_csharp(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
#         """Process using C# BmtExtract tool"""
#         try:
#             # Run C# extractor
#             process = subprocess.run(
#                 [self.extractor_path, bmt_path, output_dir],
#                 capture_output=True,
#                 text=True,
#                 timeout=30
#             )

#             if process.returncode != 0:
#                 raise RuntimeError(f"C# extractor failed: {process.stderr}")

#             # Read extracted data.json
#             json_path = os.path.join(output_dir, "data.json")
#             if not os.path.exists(json_path):
#                 raise FileNotFoundError("data.json not generated by extractor")

#             with open(json_path, "r", encoding="utf-8") as f:
#                 data = json.load(f)

#             # Process the extracted data
#             return await self._process_extracted_data(data, output_dir)

#         except subprocess.TimeoutExpired:
#             raise RuntimeError("C# extractor timeout")
#         except Exception as e:
#             raise RuntimeError(f"C# extraction failed: {str(e)}")

#     async def _process_with_python(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
#         """Fallback Python-based extraction (basic implementation)"""
#         try:
#             # Basic BMT structure parsing
#             # This is a simplified version - full implementation needs BMT format specs
            
#             with open(bmt_path, 'rb') as f:
#                 content = f.read()

#             # Try to extract embedded JPEG (real image)
#             real_image_path = None
#             jpeg_start = content.find(b'\xFF\xD8\xFF')
#             if jpeg_start != -1:
#                 jpeg_end = content.find(b'\xFF\xD9', jpeg_start)
#                 if jpeg_end != -1:
#                     jpeg_data = content[jpeg_start:jpeg_end + 2]
#                     real_image_path = os.path.join(output_dir, "real_image.jpg")
#                     with open(real_image_path, 'wb') as img_file:
#                         img_file.write(jpeg_data)

#             # Generate dummy thermal data for testing
#             # In production, you need proper BMT parsing
#             width, height = 320, 240
#             temperature_matrix = np.random.uniform(15, 35, (height, width)).tolist()
            
#             # Save as CSV
#             csv_path = os.path.join(output_dir, "thermal_data.csv")
#             with open(csv_path, 'w', newline='') as csvfile:
#                 writer = csv.writer(csvfile)
#                 for row in temperature_matrix:
#                     writer.writerow([f"{temp:.2f}" for temp in row])

#             # Generate thermal image visualization
#             thermal_image_path = self._generate_thermal_visualization(
#                 temperature_matrix,
#                 os.path.join(output_dir, "thermal_image.png")
#             )

#             metadata = {
#                 "emissivity": 0.95,
#                 "ambient_temp": 20.0,
#                 "reflected_temp": 20.0,
#                 "device": "Unknown Camera",
#                 "captured_at": datetime.utcnow().isoformat()
#             }

#             return {
#                 "success": True,
#                 "message": "BMT processed with Python fallback",
#                 "thermal_image_path": thermal_image_path,
#                 "real_image_path": real_image_path,
#                 "csv_url": csv_path,
#                 "metadata": metadata,
#                 "thermal_data": {
#                     "width": width,
#                     "height": height,
#                     "min_temp": float(np.min(temperature_matrix)),
#                     "max_temp": float(np.max(temperature_matrix))
#                 }
#             }

#         except Exception as e:
#             raise RuntimeError(f"Python extraction failed: {str(e)}")

#     async def _process_extracted_data(self, data: Dict, output_dir: str) -> Dict[str, Any]:
#         """Process data from C# extractor"""
        
#         thermal_image_path = data.get("thermal_image_path")
#         real_image_path = data.get("real_image_path")
        
#         # Extract temperature matrix from data
#         temperature_matrix = data.get("temperature_matrix", [])
        
#         if temperature_matrix:
#             # Save as CSV
#             csv_path = os.path.join(output_dir, "thermal_data.csv")
#             with open(csv_path, 'w', newline='') as csvfile:
#                 writer = csv.writer(csvfile)
#                 for row in temperature_matrix:
#                     writer.writerow([f"{temp:.2f}" for temp in row])
#         else:
#             csv_path = None

#         # Extract metadata
#         metadata = {
#             "emissivity": data.get("emissivity", 0.95),
#             "ambient_temp": data.get("ambient_temp", 20.0),
#             "reflected_temp": data.get("reflected_temp", 20.0),
#             "device": data.get("device", "Unknown"),
#             "captured_at": data.get("timestamp", datetime.utcnow().isoformat())
#         }

#         thermal_data = {
#             "width": data.get("width", 0),
#             "height": data.get("height", 0),
#             "min_temp": data.get("min_temp", 0),
#             "max_temp": data.get("max_temp", 100)
#         }

#         return {
#             "success": True,
#             "message": "BMT processed successfully",
#             "thermal_image_path": thermal_image_path,
#             "real_image_path": real_image_path,
#             "csv_url": csv_path,
#             "metadata": metadata,
#             "thermal_data": thermal_data
#         }

#     def _generate_thermal_visualization(
#         self, 
#         temperature_matrix: list, 
#         output_path: str
#     ) -> str:
#         """Generate thermal image visualization from temperature matrix"""
#         try:
#             import matplotlib
#             matplotlib.use('Agg')
#             import matplotlib.pyplot as plt
#             from matplotlib.colors import LinearSegmentedColormap

#             # Create iron colormap (similar to FLIR)
#             colors = ['#000033', '#0000aa', '#0088ff', '#00ddff', 
#                      '#88ff55', '#ffaa00', '#ff0000', '#aa0000']
#             n_bins = 256
#             cmap = LinearSegmentedColormap.from_list('iron', colors, N=n_bins)

#             # Create figure
#             fig, ax = plt.subplots(figsize=(8, 6))
#             im = ax.imshow(temperature_matrix, cmap=cmap, aspect='auto')
#             plt.colorbar(im, ax=ax, label='Temperature (°C)')
#             ax.axis('off')
            
#             plt.tight_layout()
#             plt.savefig(output_path, dpi=150, bbox_inches='tight')
#             plt.close(fig)

#             return output_path

#         except Exception as e:
#             print(f"Error generating thermal visualization: {e}")
#             # Create simple grayscale fallback
#             arr = np.array(temperature_matrix, dtype=np.float32)
#             normalized = ((arr - arr.min()) / (arr.max() - arr.min()) * 255).astype(np.uint8)
#             img = Image.fromarray(normalized, mode='L')
#             img.save(output_path)
#             return output_path

#     def cleanup_temp_files(self, max_age_hours: int = 24):
#         """Clean up old temporary files"""
#         try:
#             current_time = datetime.now()
#             for item in self.temp_dir.iterdir():
#                 if item.is_dir():
#                     # Check directory age
#                     creation_time = datetime.fromtimestamp(item.stat().st_ctime)
#                     age_hours = (current_time - creation_time).total_seconds() / 3600
                    
#                     if age_hours > max_age_hours:
#                         shutil.rmtree(item)
#         except Exception as e:
#             print(f"Error cleaning temp files: {e}")




