# server/app/services/thermal_processor.py
import os
import csv
import json
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, Optional, Any
from datetime import datetime
import numpy as np
from PIL import Image

from app.core.config import settings


class ThermalProcessor:
    """
    Handles processing of thermal BMT files.
    Extracts thermal data, real images, and generates CSV files.
    """

    def __init__(self):
        self.temp_dir = Path(tempfile.gettempdir()) / "thermal_analyzer"
        self.temp_dir.mkdir(exist_ok=True)
        
        # Path to C# extraction tool (configurable via environment)
        self.extractor_path = os.getenv(
            "BMT_EXTRACTOR_PATH",
            r"BmtExtract\BmtExtract\bin\Debug\net8.0\BmtExtract.exe"
        )

    async def process_bmt_file(self, file_path: str) -> Dict[str, Any]:
        """
        Process BMT file and extract thermal data, real image, and metadata.
        
        Returns:
        {
            "success": bool,
            "message": str,
            "thermal_image_path": str,
            "real_image_path": str,
            "csv_url": str,  # URL to CSV temperature data
            "metadata": dict,
            "thermal_data": dict
        }
        """
        try:
            # Create output directory
            output_dir = self.temp_dir / f"bmt_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            output_dir.mkdir(exist_ok=True)

            # Check if C# extractor exists
            if os.path.exists(self.extractor_path):
                # Use C# extractor
                result = await self._process_with_csharp(file_path, str(output_dir))
            else:
                # Fallback to Python-based extraction
                result = await self._process_with_python(file_path, str(output_dir))

            return result

        except Exception as e:
            return {
                "success": False,
                "message": f"Error processing BMT file: {str(e)}"
            }

    async def _process_with_csharp(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
        """Process using C# BmtExtract tool"""
        try:
            # Run C# extractor
            process = subprocess.run(
                [self.extractor_path, bmt_path, output_dir],
                capture_output=True,
                text=True,
                timeout=30
            )

            if process.returncode != 0:
                raise RuntimeError(f"C# extractor failed: {process.stderr}")

            # Read extracted data.json
            json_path = os.path.join(output_dir, "data.json")
            if not os.path.exists(json_path):
                raise FileNotFoundError("data.json not generated by extractor")

            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)

            # Process the extracted data
            return await self._process_extracted_data(data, output_dir)

        except subprocess.TimeoutExpired:
            raise RuntimeError("C# extractor timeout")
        except Exception as e:
            raise RuntimeError(f"C# extraction failed: {str(e)}")

    async def _process_with_python(self, bmt_path: str, output_dir: str) -> Dict[str, Any]:
        """Fallback Python-based extraction (basic implementation)"""
        try:
            # Basic BMT structure parsing
            # This is a simplified version - full implementation needs BMT format specs
            
            with open(bmt_path, 'rb') as f:
                content = f.read()

            # Try to extract embedded JPEG (real image)
            real_image_path = None
            jpeg_start = content.find(b'\xFF\xD8\xFF')
            if jpeg_start != -1:
                jpeg_end = content.find(b'\xFF\xD9', jpeg_start)
                if jpeg_end != -1:
                    jpeg_data = content[jpeg_start:jpeg_end + 2]
                    real_image_path = os.path.join(output_dir, "real_image.jpg")
                    with open(real_image_path, 'wb') as img_file:
                        img_file.write(jpeg_data)

            # Generate dummy thermal data for testing
            # In production, you need proper BMT parsing
            width, height = 320, 240
            temperature_matrix = np.random.uniform(15, 35, (height, width)).tolist()
            
            # Save as CSV
            csv_path = os.path.join(output_dir, "thermal_data.csv")
            with open(csv_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                for row in temperature_matrix:
                    writer.writerow([f"{temp:.2f}" for temp in row])

            # Generate thermal image visualization
            thermal_image_path = self._generate_thermal_visualization(
                temperature_matrix,
                os.path.join(output_dir, "thermal_image.png")
            )

            metadata = {
                "emissivity": 0.95,
                "ambient_temp": 20.0,
                "reflected_temp": 20.0,
                "device": "Unknown Camera",
                "captured_at": datetime.utcnow().isoformat()
            }

            return {
                "success": True,
                "message": "BMT processed with Python fallback",
                "thermal_image_path": thermal_image_path,
                "real_image_path": real_image_path,
                "csv_url": csv_path,
                "metadata": metadata,
                "thermal_data": {
                    "width": width,
                    "height": height,
                    "min_temp": float(np.min(temperature_matrix)),
                    "max_temp": float(np.max(temperature_matrix))
                }
            }

        except Exception as e:
            raise RuntimeError(f"Python extraction failed: {str(e)}")

    async def _process_extracted_data(self, data: Dict, output_dir: str) -> Dict[str, Any]:
        """Process data from C# extractor"""
        
        thermal_image_path = data.get("thermal_image_path")
        real_image_path = data.get("real_image_path")
        
        # Extract temperature matrix from data
        temperature_matrix = data.get("temperature_matrix", [])
        
        if temperature_matrix:
            # Save as CSV
            csv_path = os.path.join(output_dir, "thermal_data.csv")
            with open(csv_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                for row in temperature_matrix:
                    writer.writerow([f"{temp:.2f}" for temp in row])
        else:
            csv_path = None

        # Extract metadata
        metadata = {
            "emissivity": data.get("emissivity", 0.95),
            "ambient_temp": data.get("ambient_temp", 20.0),
            "reflected_temp": data.get("reflected_temp", 20.0),
            "device": data.get("device", "Unknown"),
            "captured_at": data.get("timestamp", datetime.utcnow().isoformat())
        }

        thermal_data = {
            "width": data.get("width", 0),
            "height": data.get("height", 0),
            "min_temp": data.get("min_temp", 0),
            "max_temp": data.get("max_temp", 100)
        }

        return {
            "success": True,
            "message": "BMT processed successfully",
            "thermal_image_path": thermal_image_path,
            "real_image_path": real_image_path,
            "csv_url": csv_path,
            "metadata": metadata,
            "thermal_data": thermal_data
        }

    def _generate_thermal_visualization(
        self, 
        temperature_matrix: list, 
        output_path: str
    ) -> str:
        """Generate thermal image visualization from temperature matrix"""
        try:
            import matplotlib
            matplotlib.use('Agg')
            import matplotlib.pyplot as plt
            from matplotlib.colors import LinearSegmentedColormap

            # Create iron colormap (similar to FLIR)
            colors = ['#000033', '#0000aa', '#0088ff', '#00ddff', 
                     '#88ff55', '#ffaa00', '#ff0000', '#aa0000']
            n_bins = 256
            cmap = LinearSegmentedColormap.from_list('iron', colors, N=n_bins)

            # Create figure
            fig, ax = plt.subplots(figsize=(8, 6))
            im = ax.imshow(temperature_matrix, cmap=cmap, aspect='auto')
            plt.colorbar(im, ax=ax, label='Temperature (Â°C)')
            ax.axis('off')
            
            plt.tight_layout()
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close(fig)

            return output_path

        except Exception as e:
            print(f"Error generating thermal visualization: {e}")
            # Create simple grayscale fallback
            arr = np.array(temperature_matrix, dtype=np.float32)
            normalized = ((arr - arr.min()) / (arr.max() - arr.min()) * 255).astype(np.uint8)
            img = Image.fromarray(normalized, mode='L')
            img.save(output_path)
            return output_path

    def cleanup_temp_files(self, max_age_hours: int = 24):
        """Clean up old temporary files"""
        try:
            current_time = datetime.now()
            for item in self.temp_dir.iterdir():
                if item.is_dir():
                    # Check directory age
                    creation_time = datetime.fromtimestamp(item.stat().st_ctime)
                    age_hours = (current_time - creation_time).total_seconds() / 3600
                    
                    if age_hours > max_age_hours:
                        shutil.rmtree(item)
        except Exception as e:
            print(f"Error cleaning temp files: {e}")